\section{Research, plan and adapt}
{This step helps optimize both time and resources by preventing unnecessary work. Since this project builds upon a previous one, it is not required to develop new code for certain application requirements, but to adapt it to the new needs. Furthermore, the availability of APIs for downloading measurements from the ACTRIS–EARLINET Data Portal \cite{earlinet_web} and AERONET web application \cite{aeronet_web} provides a convenient and efficient solution that can significantly reduce development effort.}
\smallskip
\subsection{Web services development}
\subsubsection{ACTRIS–EARLINET service} 
\smallskip
{The ACTRIS-EARLINET Data Portal provides a REST API for downloading measurements \cite{rest_api_earlinet}. This web, shows all the different requests that are supported by the API, gives examples of how to use them and the expected response.\smallskip\\
Having all this information available is really helpful, since it allows to localize the requests that are needed for the project requirements.\smallskip\\
After testing and comparing the different options and the obtained responses, it becomes clear that the best option is to use the "/products/downloads" endpoint, which allows to download the measurements in a compressed format, filtering the data by type, date and station name.\smallskip\\
Even if other configuration parameters are available (measurementID, wavelength and opticaltype), it is not necessary to use them for the project requirements.\smallskip\\
Once the behaviour is understood, a class is created to handle the requests and responses of the API.\smallskip\\
}
\begin{lstlisting}
public class EarlinetService{
    string baseUrl = "https://api.actris-ares.eu/api/services/restapi/";
    public virtual System.Threading.Tasks.Task<bool> DownloadProductByDateRangeAsync(string type,string FromDate,string ToDate,string outputFolder){
        return DownloadProductByDateRangeAsync(type,FromDate,ToDate,outputFolder,System.Threading.CancellationToken.None);
    }

    public async Task<bool> DownloadProductByDateRangeAsync(string type,string FromDate,string ToDate,string outputFilePath,System.Threading.CancellationToken cancellationToken = default){
        try{
            string url = $"{baseUrl}products/downloads?kind={type}&fromDate={FromDate}&toDate={ToDate}&stations=brc";
            using (HttpClient client = new HttpClient()){
                HttpResponseMessage response = await client.GetAsync(url);
                response.EnsureSuccessStatusCode();
                using (var fs = new FileStream(outputFilePath,FileMode.Create,FileAccess.Write,FileShare.None)){
                    await response.Content.CopyToAsync(fs);
                }
                System.IO.FileInfo f = new FileInfo(outputFilePath);
                if (f.Length <= 1048)
                    return false;
                return true;
            }
        }
        catch (Exception ex){
            return false;
        }
    }
}
\end{lstlisting}
\smallskip
{For the creation of this class it has been taken into account the fact that the DownlaodProductByDateRangeAsync method can be used in different points of the program with different configurations.It has also been implemented in such a way that adding new functionalities is easy using the same design pattern.}
\subsubsection{AERONET service}\smallskip
{The AERONET web does not provide a REST API portlet, but it includes web servicie documentation that helps the implementation of a costume service.\smallskip\\
The amount of files to be downloaded in this website is larger thant the one in Earlinet, and its documentation can be found in three different sections of the web:}
\begin{table}[htbp]
    \centering
    \caption{AERONET Data Products and Extensions}
    \label{tab:aeronet_products}
    \begin{tabularx}{\textwidth}{lXl}
        \toprule
        \textbf{Category} & \textbf{Product Description} & \textbf{Extension} \\
        \midrule
        Optical Depth \cite{aod_solar} & Aerosol Optical Depth (AOD): (descripcion de los datos) & .lev15 \\
        & Spectral Deconvolution Algorithm (SDA): (descripcion de los datos) & .ONEILL\_lev15 \\
        \addlinespace
        Aerosol Inversions \cite{inversions_aod_solar} & Inversion products: (descripcion de los datos) & .all \\
        \addlinespace
        Raw Products Optical Depth \cite{raw_aod_solar} & Raw Almucantar: (descripcion de los datos) & .alm \\
        & Raw Polarized Almucantar: (descripcion de los datos) & .alp \\
        \bottomrule
    \end{tabularx}
\end{table}
\smallskip
{For the creation of this class it has been taken into account the fact that the DownlaodProductByDateRangeAsync method can be used in different points of the program with different configurations.It has also been implemented in such a way that adding new functionalities is easy using the same design pattern. For clarity and organization, it has been created the DataType Enum, since the different data types need different Url content in order to be downloaded.\smallskip\\}
\begin{lstlisting}
public class AeronetService{
    private string baseUrl = "https://aeronet.gsfc.nasa.gov/cgi-bin/";
    public async Task DownloadDataAsync(string destinationFile,string url){
        try{
            using (HttpClient client = new HttpClient()){
                var response = await client.GetAsync(url);
                response.EnsureSuccessStatusCode();

                var content = await response.Content.ReadAsByteArrayAsync();
                await File.WriteAllBytesAsync(destinationFile,content);
            }
        }
        catch (Exception ex){
            Console.WriteLine($"Error downloading data: {ex.Message}");
        }
    }

    public string BuildUrl(DataType _dataType,DateTime startDate,DateTime endDate,string productType = "",string site = "",string product = "",string AVG = "",bool isEnabled = false){
        switch (_dataType){
            case DataType.AerosolInversions:
                if (isEnabled)
                    return BuildUrlAerosolInversions(startDate,endDate,productType,site,product,AVG);
                else
                    return BuildUrlAerosolInversions(startDate,endDate);

            case DataType.OpticalDepth:
                if (isEnabled)
                    return BuildUrlOpticalDepth(startDate,endDate,productType,site,AVG);
                else
                    return BuildUrlOpticalDepth(startDate,endDate,productType);

            case DataType.RawProductsOpticalDepth:
                if (isEnabled)
                    return BuildUrlRawProductsOpticalDepth(startDate,endDate,productType,site,AVG);
                else
                    return BuildUrlRawProductsOpticalDepth(startDate,endDate,productType);
        }
        return "";
    }
    
    {...} //BuildUrl methods can be found in GitHub repository
}
\end{lstlisting}
{In this application, this class is only used to download the data files listed above, but other types could be downloaded by calling only the DownloadDataAsync and BuildUrl methods in a line.}
\subsection{Matlab controller development}
{As it was mentioned in the introduction, this project is a second attempt to offer a solution of the same problem. \smallskip\\
While the first application proposed a complete implementation in MATLAB, the current approach differs. However, since many requirements are shared between both, the previously developed code has been adapted to the new hybrid system in order to be executed with C\#. In order to do that, different actions have been taken.}
\subsubsection{Create script configuration files and output files}
{Since the project is hybrid, it is necessary to create a configuration file for the script that will be executed in C\#. This file will contain the parameters needed to execute the script. In the previous approach, this files were not needed, since GUI introduced parameters were being stores in the MATLAB workspace. The use of these files, allow the communication between the two different languages. Configuration files allow the  different scripts to obtain the information and parameters that the user introduced, while the output files allow the application to know the corresponding results and notify the user about it.}
\subsubsection{Automatize MATLAB repository for needed data files   }
{In the older version, it was needed to manually download the data files from the different websites and at the respective files in two concretes repositories. Files downloaded from Aeronet site were located in a folder inside the Matlab Project called /repository/AERONET/. Files downloaded from Earlinet site were located in a folder inside the Matlab Project called /repository/LIDAR/ and inside this folder, a folder for each measurementID was created containing all the data files corresponding to that measure. In order to automatize this process, a script has been created that downloads the data files from the AERONET website and stores them in a local repository.\smallskip\\
In order to be able to automatize the process of downloading and giving the application the capacity of work with different workspaces, the repository location has been modified and automatized inside the application. The corresponding file is saved as configuration parameter in both, application and script.}
\subsubsection{Adapt old scripts to new file formats}
{}
\subsubsection{Execute MATLAB scripts from C\#}
{In order to execute the MATLAB scripts from C\#, it is needed to create a method that uses the ProcessStartInfo class, that can be imported as a library, to execute the MATLAB script. The following example shows a method called RunMatlabScript that takes a string parameter containing the path to the script to be executed. The method uses the Process class to execute the script and it redirects the standard output and standard error to the console.\smallskip
}
\begin{lstlisting}
public static void RunMatlabScript (string scriptPath){
    try{
        ProcessStartInfo startInfo = new ProcessStartInfo{
            FileName = "matlab",
            Arguments = $"-batch \"run('{scriptPath}')\"",
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };
        using var process = new Process { StartInfo = startInfo };
        process.OutputDataReceived += (s,e) =>{
            if (e.Data != null)
                Messenger.Default.Send<string>("WriteMatlabOutput",e.Data);
        };
        process.ErrorDataReceived += (s,e) =>{
            if (e.Data != null)
                Messenger.Default.Send<string>("WriteMatlabErrors",e.Data);
        };
        process.Start();
        process.BeginOutputReadLine();
        process.BeginErrorReadLine();
        process.WaitForExit();
        if (process.ExitCode == 0){ //OK
            Logger.Log($"Script was executed correctly,executing post execution actions . . .");
            script.PostExecutionActions();
        }
        else{
            Logger.Log($"Error occured during execution,executing post execution actions . . .");
            script.PostExecutionActions(false);
        }
    }
    catch (Exception ex){
        Logger.Log($"Error occured during execution,executing post execution actions . . .");
        script.PostExecutionActions(false);
    }
}
\end{lstlisting}
\bigskip